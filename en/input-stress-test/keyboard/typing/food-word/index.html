<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å–µå–µå¿«é¤è½¦ï¼šé”®ç›˜å¤§ä½œæˆ˜ (UIä¿®å¤ç‰ˆ) ğŸ±ğŸµ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700&display=swap');

        :root {
            --bg-color: #FFF5E1;
            --primary: #FF9AA2;
            --secondary: #B5EAD7;
            --accent: #FFDAC1;
            --text: #6B5B95;
            --white: #ffffff;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            width: 800px;
            height: 600px;
            background: var(--white);
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            border: 8px solid var(--accent);
        }

        .kitchen-bg {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 30%;
            background-color: #FFB7B2;
            border-top: 5px solid #E2F0CB;
            z-index: 1;
        }

        .chef-cat {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 80px;
            z-index: 2;
            transition: transform 0.1s;
        }

        .counter {
            position: absolute;
            bottom: 120px;
            width: 100%;
            height: 20px;
            background: #D7CCC8;
            z-index: 1;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            color: var(--text);
            font-weight: bold;
            z-index: 10;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .combo-box { color: var(--primary); }

        .customer {
            position: absolute;
            bottom: 140px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: left 0.5s ease-out, opacity 0.3s;
            z-index: 5;
        }

        .customer-avatar { font-size: 60px; }

        .order-bubble {
            background: white;
            border: 3px solid var(--text);
            border-radius: 15px;
            padding: 10px 15px;
            position: relative;
            margin-bottom: 10px;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
        }

        .word-display {
            font-family: 'Fredoka One', cursive;
            font-size: 24px;
            color: #ccc;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .char-correct { color: var(--primary); }
        .char-active { color: var(--text); text-decoration: underline; transform: scale(1.2); display:inline-block; }

        .patience-bar {
            width: 100%;
            height: 6px;
            background: #eee;
            margin-top: 5px;
            border-radius: 3px;
            overflow: hidden;
        }

        .patience-fill {
            height: 100%;
            background: #88d8b0;
            width: 100%;
            transition: width 0.1s linear, background 0.3s;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }

        h1 {
            font-family: 'Fredoka One', cursive;
            color: var(--primary);
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0 var(--secondary);
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-weight: bold;
            box-shadow: 0 5px 0 #E57373;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #E57373;
        }

        /* åŠ¨ç”»ç±» */
        .shake { animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-6px, 0, 0); }
            40%, 60% { transform: translate3d(6px, 0, 0); }
        }

        .bounce { animation: bounce 0.15s ease; }
        @keyframes bounce {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); }
        }

        .particle {
            position: absolute;
            pointer-events: none;
            animation: fly 0.8s ease-out forwards;
            font-size: 24px;
            z-index: 20;
        }
        @keyframes fly {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }
        .hidden { display: none !important; }

        /* é™éŸ³æŒ‰é’® - é‡æ–°å®šä½åˆ°å³ä¸Šè§’HUDåŒºåŸŸ */
        .mute-btn {
            cursor: pointer;
            z-index: 11;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            font-size: 28px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .mute-btn:hover { 
            opacity: 1;
            transform: scale(1.1);
        }

    </style>
</head>
<body>

    <div id="game-container">
        <div class="hud">
            <div class="hud-item">
                <span>åˆ†æ•°: <span id="score">0</span></span>
            </div>
            <div class="hud-item" style="gap: 20px;">
                <div class="mute-btn" id="mute-btn" onclick="toggleMute()">ğŸ”Š</div>
                <div>ç”Ÿå‘½: <span id="lives">â¤ï¸â¤ï¸â¤ï¸</span></div>
            </div>
            <div class="hud-item combo-box">
                è¿å‡»: x<span id="combo">0</span>
            </div>
        </div>

        <div id="start-screen" class="overlay">
            <h1>ğŸ± å–µå–µå¿«é¤è½¦ ğŸšš</h1>
            <p>ä¸ºæ£®æ—é‡Œçš„å°åŠ¨ç‰©åˆ¶ä½œç¾é£Ÿï¼</p>
            <p style="font-size: 14px; color: #888;">(åœ¨é”®ç›˜ä¸Šè¾“å…¥æ˜¾ç¤ºçš„å•è¯)</p>
            <br>
            <button onclick="initGame()">å¼€å§‹è¥ä¸š!</button>
        </div>

        <div id="game-over-screen" class="overlay hidden">
            <h1 style="color: #666;">åº—é“ºæ‰“çƒŠ</h1>
            <p>æœ€ç»ˆæ”¶å…¥: <span id="final-score" style="font-weight: bold; color: var(--primary);">0</span> é‡‘å¸</p>
            <p style="font-size: 14px; color: #888;">æœ€é«˜è¿å‡»: <span id="max-combo">0</span></p>
            <br>
            <button onclick="startGame()">å†æ¥ä¸€æ¬¡!</button>
        </div>

        <div class="counter"></div>
        <div class="kitchen-bg"></div>
        <div class="chef-cat" id="chef">ğŸ±</div>
        
        <div id="customer-area"></div>
    </div>

    <script>
        // --- ğŸµ éŸ³æ•ˆç³»ç»Ÿ (Web Audio API) ---
        let audioCtx;
        let isMuted = false;
        let lastTypeTime = 0; // æ‰“å­—éŸ³æ•ˆé˜²æŠ–

        function initAudio() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    console.log("éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–");
                } catch (e) {
                    console.error("éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥:", e);
                    // é™éŸ³æ¨¡å¼ä½œä¸ºåå¤‡
                    isMuted = true;
                    document.getElementById('mute-btn').innerText = 'ğŸ”‡';
                }
            }
            // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœè¢«æš‚åœï¼‰
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log("éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤");
                });
            }
        }

        function playTone(freq, type, duration, vol = 0.1) {
            if (isMuted || !audioCtx) return;
            
            // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºæ´»åŠ¨çŠ¶æ€
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.error("éŸ³é¢‘æ¢å¤å¤±è´¥:", e));
            }
            
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch (e) {
                console.error("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e);
            }
        }

        const sfx = {
            type: () => {
                const now = Date.now();
                if (now - lastTypeTime > 50) { // 50msé˜²æŠ–
                    playTone(800, 'sine', 0.1);
                    lastTypeTime = now;
                }
            },
            error: () => {
                playTone(150, 'sawtooth', 0.3, 0.2);
                setTimeout(() => playTone(140, 'sawtooth', 0.3, 0.2), 50);
            },
            serve: () => {
                setTimeout(() => playTone(523.25, 'triangle', 0.2, 0.15), 0);
                setTimeout(() => playTone(659.25, 'triangle', 0.2, 0.15), 100);
                setTimeout(() => playTone(783.99, 'triangle', 0.4, 0.15), 200);
            },
            gameover: () => {
                setTimeout(() => playTone(400, 'square', 0.4, 0.1), 0);
                setTimeout(() => playTone(300, 'square', 0.4, 0.1), 300);
                setTimeout(() => playTone(200, 'square', 0.8, 0.1), 600);
            },
            spawn: () => {
                playTone(600, 'sine', 0.3, 0.1);
            }
        };

        function toggleMute() {
            isMuted = !isMuted;
            document.getElementById('mute-btn').innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
            
            // å¦‚æœå–æ¶ˆé™éŸ³ï¼Œç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¿€æ´»
            if (!isMuted && audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log("éŸ³é¢‘å·²å–æ¶ˆé™éŸ³");
                });
            }
        }

        // --- æ¸¸æˆæ•°æ® ---
        const wordsEasy = ['TEA', 'ICE', 'JAM', 'EGG', 'PIE', 'HAM', 'NUT', 'BUN', 'POT', 'MILK'];
        const wordsMedium = ['SALAD', 'BREAD', 'PIZZA', 'STEAK', 'SUSHI', 'CURRY', 'PASTA', 'TACO', 'WATER', 'DONUT'];
        const wordsHard = ['BURGER', 'SANDWICH', 'PANCAKE', 'POPCORN', 'CUPCAKE', 'SAUSAGE', 'NOODLES', 'COOKIES', 'BURRITO'];
        
        const animals = ['ğŸ¶', 'ğŸ°', 'ğŸ¼', 'ğŸ¨', 'ğŸ·', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¹'];
        const foods = ['ğŸ”', 'ğŸŸ', 'ğŸ•', 'ğŸŒ­', 'ğŸ¥ª', 'ğŸŒ®', 'ğŸ¦', 'ğŸ©'];

        // --- æ¸¸æˆçŠ¶æ€ ---
        let state = {
            isPlaying: false,
            score: 0,
            maxScore: 0,
            lives: 3,
            combo: 0,
            maxCombo: 0,
            spawnRate: 3000,
            lastSpawn: 0,
            difficulty: 1,
            lastTime: 0
        };

        let customers = [];
        let animationFrameId = null;

        // --- DOM å…ƒç´  ---
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const comboEl = document.getElementById('combo');
        const finalScoreEl = document.getElementById('final-score');
        const maxComboEl = document.getElementById('max-combo');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const customerArea = document.getElementById('customer-area');
        const chef = document.getElementById('chef');
        const container = document.getElementById('game-container');

        // --- æ¸¸æˆé€»è¾‘ ---

        function initGame() {
            initAudio(); // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¿…é¡»åœ¨ç”¨æˆ·ç‚¹å‡»åï¼‰
            startGame();
        }

        function startGame() {
            // åœæ­¢ä¹‹å‰çš„æ¸¸æˆå¾ªç¯
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            state = {
                isPlaying: true,
                score: 0,
                maxScore: Math.max(state.maxScore, state.score),
                lives: 3,
                combo: 0,
                maxCombo: 0,
                spawnRate: 2500,
                lastSpawn: 0,
                difficulty: 1,
                lastTime: 0
            };
            
            customers = [];
            customerArea.innerHTML = ''; 
            
            updateUI();
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            // åˆå§‹ç”Ÿæˆä¸€ä¸ªé¡¾å®¢
            spawnCustomer();
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            state.lastTime = performance.now();
            gameLoop(state.lastTime);
        }

        function gameLoop(timestamp) {
            if (!state.isPlaying) return;
            
            const deltaTime = timestamp - state.lastTime;
            state.lastTime = timestamp;

            // ç”Ÿæˆæ–°é¡¾å®¢
            if (timestamp - state.lastSpawn > state.spawnRate) {
                spawnCustomer();
                state.lastSpawn = timestamp;
                // é€æ¸åŠ å¿«ç”Ÿæˆé€Ÿåº¦ï¼Œä½†è®¾ç½®ä¸‹é™
                if (state.spawnRate > 1000) state.spawnRate -= 15;
            }

            // æ›´æ–°æ‰€æœ‰é¡¾å®¢çš„è€å¿ƒå€¼
            customers.forEach((c, index) => {
                if (c.remove) return;
                
                c.patience -= 0.15 * state.difficulty * (deltaTime / 16.67); // åŸºäºæ—¶é—´çš„æ›´æ–°
                if (c.patience < 0) c.patience = 0;
                
                updateCustomerUI(c);

                if (c.patience <= 0) {
                    customerLeave(c.id, false);
                }
            });

            // æ¸…ç†å·²æ ‡è®°åˆ é™¤çš„é¡¾å®¢
            customers = customers.filter(c => !c.remove);

            // æ£€æŸ¥æ¸¸æˆç»“æŸ
            if (state.lives <= 0) {
                gameOver();
                return;
            }

            // ç»§ç»­æ¸¸æˆå¾ªç¯
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function getWord() {
            let pool = [...wordsEasy];
            if (state.score > 200) pool = pool.concat(wordsMedium);
            if (state.score > 500) pool = pool.concat(wordsHard);
            state.difficulty = 1 + Math.floor(state.score / 500) * 0.2;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        function spawnCustomer() {
            // é™åˆ¶æœ€å¤šåŒæ—¶4ä¸ªé¡¾å®¢
            const existingCustomers = customerArea.children.length;
            if (existingCustomers >= 4) return;

            const word = getWord();
            const id = 'c' + Date.now() + Math.random().toString(36).substr(2, 9);
            const avatar = animals[Math.floor(Math.random() * animals.length)];
            const foodIcon = foods[Math.floor(Math.random() * foods.length)];

            const el = document.createElement('div');
            el.className = 'customer';
            el.id = `customer-${id}`;
            el.style.left = '850px';
            el.innerHTML = `
                <div class="order-bubble">
                    <div style="font-size:20px; margin-bottom:5px;">${foodIcon}</div>
                    <div class="word-display" id="word-${id}">${formatWord(word, 0)}</div>
                    <div class="patience-bar"><div class="patience-fill" id="fill-${id}"></div></div>
                </div>
                <div class="customer-avatar">${avatar}</div>
            `;

            customerArea.appendChild(el);

            // ä½¿ç”¨å®é™…DOMä¸­çš„é¡¾å®¢æ•°é‡è®¡ç®—ä½ç½®
            const activeCustomerElements = Array.from(customerArea.children).filter(el => !el.style.opacity || el.style.opacity === '1');
            const pos = 50 + (activeCustomerElements.length * 180);
            
            setTimeout(() => {
                if (el.parentNode) {
                    el.style.left = pos + 'px';
                }
            }, 50);

            customers.push({
                id: id,
                word: word,
                typedIndex: 0,
                patience: 100,
                el: el,
                remove: false
            });
            
            // æ’­æ”¾ç”ŸæˆéŸ³æ•ˆ
            sfx.spawn();
        }

        function formatWord(word, index) {
            let html = '';
            for (let i = 0; i < word.length; i++) {
                if (i < index) {
                    html += `<span class="char-correct">${word[i]}</span>`;
                } else if (i === index) {
                    html += `<span class="char-active">${word[i]}</span>`;
                } else {
                    html += `<span>${word[i]}</span>`;
                }
            }
            return html;
        }

        function updateCustomerUI(customer) {
            const bar = document.getElementById(`fill-${customer.id}`);
            if (bar) {
                bar.style.width = customer.patience + '%';
                if (customer.patience < 30) bar.style.background = '#FF6B6B';
                else if (customer.patience < 60) bar.style.background = '#FFD166';
                else bar.style.background = '#88d8b0';
            }
        }

        function customerLeave(customerId, isHappy) {
            const customerIndex = customers.findIndex(c => c.id === customerId);
            if (customerIndex === -1) return;
            
            const c = customers[customerIndex];
            c.remove = true;
            
            if (isHappy) {
                sfx.serve(); // ğŸµ æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
                spawnParticles(c.el.offsetLeft + 50, c.el.offsetTop);
                c.el.innerHTML = `<div class="customer-avatar">âœ¨ğŸ˜»âœ¨</div>`;
                
                const wordScore = c.word.length * 10;
                const comboBonus = state.combo * 5;
                state.score += wordScore + comboBonus;
                state.combo++;
                state.maxCombo = Math.max(state.maxCombo, state.combo);
            } else {
                sfx.error(); // ğŸµ æ’­æ”¾å¤±è´¥éŸ³æ•ˆ
                c.el.innerHTML = `<div class="customer-avatar">ğŸ’¢ğŸ‘ºğŸ’¢</div>`;
                container.classList.add('shake');
                setTimeout(() => container.classList.remove('shake'), 300);
                state.lives--;
                state.combo = 0;
            }

            c.el.style.opacity = '0';
            c.el.style.transform = 'translateY(-20px)';
            
            setTimeout(() => {
                if (c.el.parentNode) c.el.parentNode.removeChild(c.el);
                repositionCustomers();
            }, 500);

            updateUI();
        }

        function repositionCustomers() {
            const activeCustomers = customers.filter(c => !c.remove);
            activeCustomers.forEach((c, i) => {
                const el = document.getElementById(`customer-${c.id}`);
                if (el) {
                    el.style.left = (50 + i * 180) + 'px';
                }
            });
        }

        // --- è¾“å…¥å¤„ç† ---
        let keyHandler;
        
        function setupKeyboardListener() {
            if (keyHandler) {
                document.removeEventListener('keydown', keyHandler);
            }
            
            keyHandler = (e) => {
                if (!state.isPlaying) return;
                
                // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºæ´»åŠ¨çŠ¶æ€
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume().catch(e => console.error("éŸ³é¢‘æ¢å¤å¤±è´¥:", e));
                }
                
                const key = e.key.toUpperCase();
                if (!/^[A-Z]$/.test(key)) return;
                
                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœªå®Œæˆçš„é¡¾å®¢
                let targetCustomer = null;
                for (const customer of customers) {
                    if (!customer.remove && customer.typedIndex < customer.word.length) {
                        targetCustomer = customer;
                        break;
                    }
                }
                
                if (!targetCustomer) return;

                const targetChar = targetCustomer.word[targetCustomer.typedIndex];

                if (key === targetChar) {
                    sfx.type(); // ğŸµ æ’­æ”¾æ‰“å­—éŸ³æ•ˆ
                    targetCustomer.typedIndex++;
                    
                    document.getElementById(`word-${targetCustomer.id}`).innerHTML = 
                        formatWord(targetCustomer.word, targetCustomer.typedIndex);
                    
                    // å¨å¸ˆåŠ¨ç”»
                    chef.classList.remove('bounce');
                    void chef.offsetWidth; // è§¦å‘é‡ç»˜
                    chef.classList.add('bounce');

                    if (targetCustomer.typedIndex === targetCustomer.word.length) {
                        customerLeave(targetCustomer.id, true);
                    }
                } else {
                    sfx.error(); // ğŸµ æ’­æ”¾é”™è¯¯éŸ³æ•ˆ
                    state.combo = 0;
                    updateUI();
                    container.classList.add('shake');
                    setTimeout(() => container.classList.remove('shake'), 300);
                }
            };
            
            document.addEventListener('keydown', keyHandler);
        }

        function updateUI() {
            scoreEl.innerText = state.score;
            comboEl.innerText = state.combo;
            
            // æ›´æ–°ç”Ÿå‘½å€¼æ˜¾ç¤º
            let livesStr = '';
            for(let i = 0; i < 3; i++) {
                if (i < state.lives) {
                    livesStr += 'â¤ï¸';
                } else {
                    livesStr += 'â™¡';
                }
            }
            livesEl.innerText = livesStr;
            
            // æ›´æ–°é™éŸ³æŒ‰é’®çŠ¶æ€
            document.getElementById('mute-btn').innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
        }

        function gameOver() {
            state.isPlaying = false;
            
            // åœæ­¢æ¸¸æˆå¾ªç¯
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            sfx.gameover(); // ğŸµ æ’­æ”¾æ¸¸æˆç»“æŸéŸ³æ•ˆ
            finalScoreEl.innerText = state.score;
            maxComboEl.innerText = state.maxCombo;
            gameOverScreen.classList.remove('hidden');
        }

        function spawnParticles(x, y) {
            for (let i = 0; i < 10; i++) {
                const p = document.createElement('div');
                p.innerText = ['â­', 'âœ¨', 'ğŸ’°', 'ğŸµ'][Math.floor(Math.random()*4)];
                p.className = 'particle';
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                
                const tx = (Math.random() - 0.5) * 100;
                const ty = (Math.random() - 0.5) * 100 - 50;
                
                p.style.setProperty('--tx', `${tx}px`);
                p.style.setProperty('--ty', `${ty}px`);
                
                container.appendChild(p);
                setTimeout(() => {
                    if (p.parentNode) p.parentNode.removeChild(p);
                }, 800);
            }
        }

        // åˆå§‹åŒ–é”®ç›˜ç›‘å¬å™¨
        setupKeyboardListener();
        
        // é¡µé¢å¯è§æ€§å˜åŒ–å¤„ç†
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && audioCtx) {
                // é¡µé¢éšè—æ—¶æš‚åœéŸ³é¢‘ä¸Šä¸‹æ–‡
                if (audioCtx.state === 'running') {
                    audioCtx.suspend().catch(e => console.error("æš‚åœéŸ³é¢‘å¤±è´¥:", e));
                }
            } else if (audioCtx && audioCtx.state === 'suspended') {
                // é¡µé¢é‡æ–°å¯è§æ—¶æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡
                audioCtx.resume().catch(e => console.error("æ¢å¤éŸ³é¢‘å¤±è´¥:", e));
            }
        });

        // çª—å£å¤±å»ç„¦ç‚¹æ—¶æš‚åœæ¸¸æˆ
        window.addEventListener('blur', function() {
            if (state.isPlaying) {
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æš‚åœåŠŸèƒ½
                console.log("æ¸¸æˆæš‚åœ - çª—å£å¤±å»ç„¦ç‚¹");
            }
        });

        // çª—å£é‡æ–°è·å¾—ç„¦ç‚¹æ—¶æ¢å¤éŸ³é¢‘
        window.addEventListener('focus', function() {
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.error("æ¢å¤éŸ³é¢‘å¤±è´¥:", e));
            }
        });

    </script>
</body>
</html>